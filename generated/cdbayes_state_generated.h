// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CDBAYESSTATE_H_
#define FLATBUFFERS_GENERATED_CDBAYESSTATE_H_

#include "flatbuffers/flatbuffers.h"

struct Triplet;

struct RegularizationPath;
struct RegularizationPathBuilder;
struct RegularizationPathT;

struct RegularizationPathState;
struct RegularizationPathStateBuilder;
struct RegularizationPathStateT;

struct CDBayesState;
struct CDBayesStateBuilder;
struct CDBayesStateT;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Triplet FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t i_;
  int32_t j_;
  double v_;

 public:
  Triplet() {
    memset(static_cast<void *>(this), 0, sizeof(Triplet));
  }
  Triplet(int32_t _i, int32_t _j, double _v)
      : i_(flatbuffers::EndianScalar(_i)),
        j_(flatbuffers::EndianScalar(_j)),
        v_(flatbuffers::EndianScalar(_v)) {
  }
  int32_t i() const {
    return flatbuffers::EndianScalar(i_);
  }
  void mutate_i(int32_t _i) {
    flatbuffers::WriteScalar(&i_, _i);
  }
  int32_t j() const {
    return flatbuffers::EndianScalar(j_);
  }
  void mutate_j(int32_t _j) {
    flatbuffers::WriteScalar(&j_, _j);
  }
  double v() const {
    return flatbuffers::EndianScalar(v_);
  }
  void mutate_v(double _v) {
    flatbuffers::WriteScalar(&v_, _v);
  }
};
FLATBUFFERS_STRUCT_END(Triplet, 16);

struct RegularizationPathT : public flatbuffers::NativeTable {
  typedef RegularizationPath TableType;
  double cost;
  double lambda;
  std::vector<Triplet> betas;
  RegularizationPathT()
      : cost(0.0),
        lambda(0.0) {
  }
};

struct RegularizationPath FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RegularizationPathT NativeTableType;
  typedef RegularizationPathBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COST = 4,
    VT_LAMBDA = 6,
    VT_BETAS = 8
  };
  double cost() const {
    return GetField<double>(VT_COST, 0.0);
  }
  bool mutate_cost(double _cost) {
    return SetField<double>(VT_COST, _cost, 0.0);
  }
  double lambda() const {
    return GetField<double>(VT_LAMBDA, 0.0);
  }
  bool mutate_lambda(double _lambda) {
    return SetField<double>(VT_LAMBDA, _lambda, 0.0);
  }
  const flatbuffers::Vector<const Triplet *> *betas() const {
    return GetPointer<const flatbuffers::Vector<const Triplet *> *>(VT_BETAS);
  }
  flatbuffers::Vector<const Triplet *> *mutable_betas() {
    return GetPointer<flatbuffers::Vector<const Triplet *> *>(VT_BETAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_COST) &&
           VerifyField<double>(verifier, VT_LAMBDA) &&
           VerifyOffset(verifier, VT_BETAS) &&
           verifier.VerifyVector(betas()) &&
           verifier.EndTable();
  }
  RegularizationPathT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RegularizationPathT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RegularizationPath> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegularizationPathT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RegularizationPathBuilder {
  typedef RegularizationPath Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cost(double cost) {
    fbb_.AddElement<double>(RegularizationPath::VT_COST, cost, 0.0);
  }
  void add_lambda(double lambda) {
    fbb_.AddElement<double>(RegularizationPath::VT_LAMBDA, lambda, 0.0);
  }
  void add_betas(flatbuffers::Offset<flatbuffers::Vector<const Triplet *>> betas) {
    fbb_.AddOffset(RegularizationPath::VT_BETAS, betas);
  }
  explicit RegularizationPathBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RegularizationPathBuilder &operator=(const RegularizationPathBuilder &);
  flatbuffers::Offset<RegularizationPath> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RegularizationPath>(end);
    return o;
  }
};

inline flatbuffers::Offset<RegularizationPath> CreateRegularizationPath(
    flatbuffers::FlatBufferBuilder &_fbb,
    double cost = 0.0,
    double lambda = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<const Triplet *>> betas = 0) {
  RegularizationPathBuilder builder_(_fbb);
  builder_.add_lambda(lambda);
  builder_.add_cost(cost);
  builder_.add_betas(betas);
  return builder_.Finish();
}

inline flatbuffers::Offset<RegularizationPath> CreateRegularizationPathDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double cost = 0.0,
    double lambda = 0.0,
    const std::vector<Triplet> *betas = nullptr) {
  auto betas__ = betas ? _fbb.CreateVectorOfStructs<Triplet>(*betas) : 0;
  return CreateRegularizationPath(
      _fbb,
      cost,
      lambda,
      betas__);
}

flatbuffers::Offset<RegularizationPath> CreateRegularizationPath(flatbuffers::FlatBufferBuilder &_fbb, const RegularizationPathT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RegularizationPathStateT : public flatbuffers::NativeTable {
  typedef RegularizationPathState TableType;
  int32_t rv;
  int32_t lastPathIdx;
  bool done;
  std::vector<std::unique_ptr<RegularizationPathT>> path;
  RegularizationPathStateT()
      : rv(0),
        lastPathIdx(0),
        done(false) {
  }
};

struct RegularizationPathState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RegularizationPathStateT NativeTableType;
  typedef RegularizationPathStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RV = 4,
    VT_LASTPATHIDX = 6,
    VT_DONE = 8,
    VT_PATH = 10
  };
  int32_t rv() const {
    return GetField<int32_t>(VT_RV, 0);
  }
  bool mutate_rv(int32_t _rv) {
    return SetField<int32_t>(VT_RV, _rv, 0);
  }
  int32_t lastPathIdx() const {
    return GetField<int32_t>(VT_LASTPATHIDX, 0);
  }
  bool mutate_lastPathIdx(int32_t _lastPathIdx) {
    return SetField<int32_t>(VT_LASTPATHIDX, _lastPathIdx, 0);
  }
  bool done() const {
    return GetField<uint8_t>(VT_DONE, 0) != 0;
  }
  bool mutate_done(bool _done) {
    return SetField<uint8_t>(VT_DONE, static_cast<uint8_t>(_done), 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<RegularizationPath>> *path() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RegularizationPath>> *>(VT_PATH);
  }
  flatbuffers::Vector<flatbuffers::Offset<RegularizationPath>> *mutable_path() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<RegularizationPath>> *>(VT_PATH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RV) &&
           VerifyField<int32_t>(verifier, VT_LASTPATHIDX) &&
           VerifyField<uint8_t>(verifier, VT_DONE) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyVector(path()) &&
           verifier.VerifyVectorOfTables(path()) &&
           verifier.EndTable();
  }
  RegularizationPathStateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RegularizationPathStateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RegularizationPathState> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegularizationPathStateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RegularizationPathStateBuilder {
  typedef RegularizationPathState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rv(int32_t rv) {
    fbb_.AddElement<int32_t>(RegularizationPathState::VT_RV, rv, 0);
  }
  void add_lastPathIdx(int32_t lastPathIdx) {
    fbb_.AddElement<int32_t>(RegularizationPathState::VT_LASTPATHIDX, lastPathIdx, 0);
  }
  void add_done(bool done) {
    fbb_.AddElement<uint8_t>(RegularizationPathState::VT_DONE, static_cast<uint8_t>(done), 0);
  }
  void add_path(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RegularizationPath>>> path) {
    fbb_.AddOffset(RegularizationPathState::VT_PATH, path);
  }
  explicit RegularizationPathStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RegularizationPathStateBuilder &operator=(const RegularizationPathStateBuilder &);
  flatbuffers::Offset<RegularizationPathState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RegularizationPathState>(end);
    return o;
  }
};

inline flatbuffers::Offset<RegularizationPathState> CreateRegularizationPathState(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rv = 0,
    int32_t lastPathIdx = 0,
    bool done = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RegularizationPath>>> path = 0) {
  RegularizationPathStateBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_lastPathIdx(lastPathIdx);
  builder_.add_rv(rv);
  builder_.add_done(done);
  return builder_.Finish();
}

inline flatbuffers::Offset<RegularizationPathState> CreateRegularizationPathStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rv = 0,
    int32_t lastPathIdx = 0,
    bool done = false,
    const std::vector<flatbuffers::Offset<RegularizationPath>> *path = nullptr) {
  auto path__ = path ? _fbb.CreateVector<flatbuffers::Offset<RegularizationPath>>(*path) : 0;
  return CreateRegularizationPathState(
      _fbb,
      rv,
      lastPathIdx,
      done,
      path__);
}

flatbuffers::Offset<RegularizationPathState> CreateRegularizationPathState(flatbuffers::FlatBufferBuilder &_fbb, const RegularizationPathStateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CDBayesStateT : public flatbuffers::NativeTable {
  typedef CDBayesState TableType;
  int32_t eras;
  std::vector<int32_t> currentEraRVs;
  std::vector<double> lambdas;
  std::vector<std::unique_ptr<RegularizationPathStateT>> states;
  CDBayesStateT()
      : eras(0) {
  }
};

struct CDBayesState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CDBayesStateT NativeTableType;
  typedef CDBayesStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERAS = 4,
    VT_CURRENTERARVS = 6,
    VT_LAMBDAS = 8,
    VT_STATES = 10
  };
  int32_t eras() const {
    return GetField<int32_t>(VT_ERAS, 0);
  }
  bool mutate_eras(int32_t _eras) {
    return SetField<int32_t>(VT_ERAS, _eras, 0);
  }
  const flatbuffers::Vector<int32_t> *currentEraRVs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CURRENTERARVS);
  }
  flatbuffers::Vector<int32_t> *mutable_currentEraRVs() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_CURRENTERARVS);
  }
  const flatbuffers::Vector<double> *lambdas() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_LAMBDAS);
  }
  flatbuffers::Vector<double> *mutable_lambdas() {
    return GetPointer<flatbuffers::Vector<double> *>(VT_LAMBDAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<RegularizationPathState>> *states() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RegularizationPathState>> *>(VT_STATES);
  }
  flatbuffers::Vector<flatbuffers::Offset<RegularizationPathState>> *mutable_states() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<RegularizationPathState>> *>(VT_STATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERAS) &&
           VerifyOffset(verifier, VT_CURRENTERARVS) &&
           verifier.VerifyVector(currentEraRVs()) &&
           VerifyOffset(verifier, VT_LAMBDAS) &&
           verifier.VerifyVector(lambdas()) &&
           VerifyOffset(verifier, VT_STATES) &&
           verifier.VerifyVector(states()) &&
           verifier.VerifyVectorOfTables(states()) &&
           verifier.EndTable();
  }
  CDBayesStateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CDBayesStateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CDBayesState> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CDBayesStateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CDBayesStateBuilder {
  typedef CDBayesState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eras(int32_t eras) {
    fbb_.AddElement<int32_t>(CDBayesState::VT_ERAS, eras, 0);
  }
  void add_currentEraRVs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> currentEraRVs) {
    fbb_.AddOffset(CDBayesState::VT_CURRENTERARVS, currentEraRVs);
  }
  void add_lambdas(flatbuffers::Offset<flatbuffers::Vector<double>> lambdas) {
    fbb_.AddOffset(CDBayesState::VT_LAMBDAS, lambdas);
  }
  void add_states(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RegularizationPathState>>> states) {
    fbb_.AddOffset(CDBayesState::VT_STATES, states);
  }
  explicit CDBayesStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CDBayesStateBuilder &operator=(const CDBayesStateBuilder &);
  flatbuffers::Offset<CDBayesState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CDBayesState>(end);
    return o;
  }
};

inline flatbuffers::Offset<CDBayesState> CreateCDBayesState(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eras = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> currentEraRVs = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> lambdas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RegularizationPathState>>> states = 0) {
  CDBayesStateBuilder builder_(_fbb);
  builder_.add_states(states);
  builder_.add_lambdas(lambdas);
  builder_.add_currentEraRVs(currentEraRVs);
  builder_.add_eras(eras);
  return builder_.Finish();
}

inline flatbuffers::Offset<CDBayesState> CreateCDBayesStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t eras = 0,
    const std::vector<int32_t> *currentEraRVs = nullptr,
    const std::vector<double> *lambdas = nullptr,
    const std::vector<flatbuffers::Offset<RegularizationPathState>> *states = nullptr) {
  auto currentEraRVs__ = currentEraRVs ? _fbb.CreateVector<int32_t>(*currentEraRVs) : 0;
  auto lambdas__ = lambdas ? _fbb.CreateVector<double>(*lambdas) : 0;
  auto states__ = states ? _fbb.CreateVector<flatbuffers::Offset<RegularizationPathState>>(*states) : 0;
  return CreateCDBayesState(
      _fbb,
      eras,
      currentEraRVs__,
      lambdas__,
      states__);
}

flatbuffers::Offset<CDBayesState> CreateCDBayesState(flatbuffers::FlatBufferBuilder &_fbb, const CDBayesStateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline RegularizationPathT *RegularizationPath::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<RegularizationPathT> _o = std::unique_ptr<RegularizationPathT>(new RegularizationPathT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RegularizationPath::UnPackTo(RegularizationPathT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cost(); _o->cost = _e; }
  { auto _e = lambda(); _o->lambda = _e; }
  { auto _e = betas(); if (_e) { _o->betas.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->betas[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<RegularizationPath> RegularizationPath::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegularizationPathT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRegularizationPath(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RegularizationPath> CreateRegularizationPath(flatbuffers::FlatBufferBuilder &_fbb, const RegularizationPathT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RegularizationPathT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cost = _o->cost;
  auto _lambda = _o->lambda;
  auto _betas = _o->betas.size() ? _fbb.CreateVectorOfStructs(_o->betas) : 0;
  return CreateRegularizationPath(
      _fbb,
      _cost,
      _lambda,
      _betas);
}

inline RegularizationPathStateT *RegularizationPathState::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<RegularizationPathStateT> _o = std::unique_ptr<RegularizationPathStateT>(new RegularizationPathStateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RegularizationPathState::UnPackTo(RegularizationPathStateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rv(); _o->rv = _e; }
  { auto _e = lastPathIdx(); _o->lastPathIdx = _e; }
  { auto _e = done(); _o->done = _e; }
  { auto _e = path(); if (_e) { _o->path.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->path[_i] = std::unique_ptr<RegularizationPathT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<RegularizationPathState> RegularizationPathState::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegularizationPathStateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRegularizationPathState(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RegularizationPathState> CreateRegularizationPathState(flatbuffers::FlatBufferBuilder &_fbb, const RegularizationPathStateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RegularizationPathStateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rv = _o->rv;
  auto _lastPathIdx = _o->lastPathIdx;
  auto _done = _o->done;
  auto _path = _o->path.size() ? _fbb.CreateVector<flatbuffers::Offset<RegularizationPath>> (_o->path.size(), [](size_t i, _VectorArgs *__va) { return CreateRegularizationPath(*__va->__fbb, __va->__o->path[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CreateRegularizationPathState(
      _fbb,
      _rv,
      _lastPathIdx,
      _done,
      _path);
}

inline CDBayesStateT *CDBayesState::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<CDBayesStateT> _o = std::unique_ptr<CDBayesStateT>(new CDBayesStateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CDBayesState::UnPackTo(CDBayesStateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = eras(); _o->eras = _e; }
  { auto _e = currentEraRVs(); if (_e) { _o->currentEraRVs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->currentEraRVs[_i] = _e->Get(_i); } } }
  { auto _e = lambdas(); if (_e) { _o->lambdas.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lambdas[_i] = _e->Get(_i); } } }
  { auto _e = states(); if (_e) { _o->states.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->states[_i] = std::unique_ptr<RegularizationPathStateT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<CDBayesState> CDBayesState::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CDBayesStateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCDBayesState(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CDBayesState> CreateCDBayesState(flatbuffers::FlatBufferBuilder &_fbb, const CDBayesStateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CDBayesStateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _eras = _o->eras;
  auto _currentEraRVs = _o->currentEraRVs.size() ? _fbb.CreateVector(_o->currentEraRVs) : 0;
  auto _lambdas = _o->lambdas.size() ? _fbb.CreateVector(_o->lambdas) : 0;
  auto _states = _o->states.size() ? _fbb.CreateVector<flatbuffers::Offset<RegularizationPathState>> (_o->states.size(), [](size_t i, _VectorArgs *__va) { return CreateRegularizationPathState(*__va->__fbb, __va->__o->states[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CreateCDBayesState(
      _fbb,
      _eras,
      _currentEraRVs,
      _lambdas,
      _states);
}

inline const CDBayesState *GetCDBayesState(const void *buf) {
  return flatbuffers::GetRoot<CDBayesState>(buf);
}

inline const CDBayesState *GetSizePrefixedCDBayesState(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<CDBayesState>(buf);
}

inline CDBayesState *GetMutableCDBayesState(void *buf) {
  return flatbuffers::GetMutableRoot<CDBayesState>(buf);
}

inline bool VerifyCDBayesStateBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<CDBayesState>(nullptr);
}

inline bool VerifySizePrefixedCDBayesStateBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<CDBayesState>(nullptr);
}

inline void FinishCDBayesStateBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<CDBayesState> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCDBayesStateBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<CDBayesState> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<CDBayesStateT> UnPackCDBayesState(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<CDBayesStateT>(GetCDBayesState(buf)->UnPack(res));
}

inline std::unique_ptr<CDBayesStateT> UnPackSizePrefixedCDBayesState(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<CDBayesStateT>(GetSizePrefixedCDBayesState(buf)->UnPack(res));
}

#endif  // FLATBUFFERS_GENERATED_CDBAYESSTATE_H_
